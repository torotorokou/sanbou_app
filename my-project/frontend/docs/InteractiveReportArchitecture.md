# インタラクティブレポートの設計アプローチ比較

## 1. 自己完結型アプローチ（推奨）

### 特徴
- **独立性**: 各コンポーネントが独自のモーダル、ステップ管理、状態を持つ
- **カプセル化**: 内部状態と処理が外部に漏れない
- **再利用性**: 他のダッシュボードでも簡単に使用可能

### 実装例
```tsx
// 自己完結型コンポーネント
<BlockUnitPriceWorkflowSelfContained
    visible={isVisible}
    onClose={() => setIsVisible(false)}
    onComplete={(result) => handleResult(result)}
    csvFile={file}
    config={{
        title: 'カスタムタイトル',
        steps: [...]
    }}
/>
```

### メリット
✅ **シンプルな統合**: 親コンポーネントは開始・終了のみを管理
✅ **保守性**: 各レポートの修正が他に影響しない
✅ **拡張性**: 新しいステップや機能を独立して追加可能
✅ **テスト容易性**: 単体でテスト可能
✅ **エラー処理**: 内部でエラーハンドリングが完結

### デメリット
❌ **コード重複**: Modal、Steps等の共通UI部分
❌ **統一性**: デザインの統一性を保つには設定が必要

---

## 2. 親子協調型アプローチ（現在の実装）

### 特徴
- **中央管理**: 親コンポーネントがモーダル、ステップ制御を担当
- **子コンポーネント**: 各ステップの内容のみを担当
- **Window通信**: window.workflowValidationでの親子間通信

### 実装例
```tsx
// 親コンポーネント
<Modal visible={isVisible}>
    <Steps current={currentStep} />
    <WorkflowStepComponent 
        currentStep={currentStep}
        onValidationChange={updateValidation}
    />
    <Button onClick={nextStep} disabled={!canProceed} />
</Modal>
```

### メリット
✅ **統一性**: モーダル、ステップの見た目が統一される
✅ **共通化**: Modal、Steps等の共通UI部分の重複なし
✅ **一元管理**: ステップ制御ロジックが一箇所に集約

### デメリット
❌ **複雑性**: 親子間のデータ同期が複雑
❌ **依存性**: 子コンポーネントが親の実装に依存
❌ **拡張困難**: 新しいステップ追加時に親の修正が必要
❌ **Window汚染**: グローバル変数での通信
❌ **テスト困難**: 親子セットでないとテスト不可

---

## 3. 推奨される設計決定

### 自己完結型を採用する理由

1. **スケーラビリティ**: 
   - 新しいインタラクティブレポートを追加する際、既存コードへの影響がない
   - 各レポートが独立してバージョンアップ可能

2. **保守性**:
   - バグ修正や機能追加が局所化される
   - 一つのレポートの問題が他に波及しない

3. **開発効率**:
   - 開発者が一つのファイルに集中できる
   - 親子間の複雑な通信プロトコルを理解する必要がない

4. **ユーザビリティ**:
   - エラー処理が内部で完結するため、より堅牢
   - カスタマイズ性が高い（タイトル、ステップ名など）

### 実装移行計画

1. **Phase 1**: 新規レポートは自己完結型で実装
2. **Phase 2**: 既存レポートを段階的に自己完結型に移行
3. **Phase 3**: 親子協調型の共通部品を削除

### 共通化すべき部分

自己完結型でも以下は共通化できます：
- CSS スタイル
- 型定義（props interface）
- ユーティリティ関数
- エラー処理パターン

```tsx
// 共通の基底クラス例
interface BaseInteractiveWorkflowProps {
    visible?: boolean;
    onClose?: () => void;
    onComplete?: (result: unknown) => void;
    config?: WorkflowConfig;
}
```

---

## 4. 結論

**自己完結型アプローチを強く推奨**します。

短期的には若干のコード重複がありますが、長期的な保守性、拡張性、開発効率を考慮すると、自己完結型の方が大きなメリットをもたらします。

特に、複数の開発者が同時に異なるレポートを開発する場合や、将来的にレポート機能が大幅に拡張される可能性を考えると、自己完結型の独立性は非常に価値があります。
