# リファクタリング設計書

- 作成日: 2025-11-28
- 対象プロジェクト: sanbou_app（想定）
- 対象コンテナ: `local_dev`

---

## 1. リファクタリングの目的

### 1.1 背景（例）

- sales-tree 周りの命名・責務が不統一で、機能追加やバグ修正時の影響範囲が読みにくい。
- DTO・ドメイン・DB カラム名がそれぞれ別名になっており、フロント/バックエンド間の変換が散在している。

### 1.2 目的

- カラム名・DTO・ドメインモデルの命名を整理し、「翻訳ポイント（変換処理）」を 1 か所に集約する。
- FSD + MVVM（Hooks=ViewModel）+ Repository パターン / Clean Architecture（UseCase + Domain + Ports + Adapters）に沿った責務分割に整理する。
- 機能仕様を変えずに、コードの可読性・変更容易性・テスト容易性を高める。

### 1.3 成功条件（評価指標）

- 機能仕様（画面の挙動・API I/F・DB 入出力）がリファクタリング前と同等であること。
- 既存バグが増えない（重大障害が発生しない）こと。
- 主要ユースケースのテスト（単体 / API / 画面）が自動化または明文化されていること。
- 変更後のコード構造が、FSD + MVVM + Repository / Clean Architecture のレイヤー構成に沿っていること。

---

## 2. 対象範囲

### 2.1 対象レイヤー（例）

- フロントエンド
  - `frontend/src/features/analytics/sales-tree/**`
  - `frontend/src/features/analytics/customer-list/**`
- バックエンド（FastAPI）
  - `app/api/routers/sales_tree.py`
  - `app/core/usecases/sales_tree/**`
  - `app/core/domain/sales_tree/**`
  - `app/core/ports/sales_tree_repository.py`
  - `app/infra/adapters/sales_tree_repository_impl.py`

※ 実際のパスはプロジェクト構成に合わせて修正する。

### 2.2 対象外（例）

- 他ドメイン（搬入量予測 / KPI / King CSV など）のビジネスロジック変更。
- DB スキーマ（テーブル定義）そのものの変更。
- 外部インターフェース（他システムとの連携仕様）の追加・削除。

---

## 3. 影響範囲

### 3.1 API

- 変更対象エンドポイント（例）
  - `GET /api/sales/tree`
  - `GET /api/sales/customer_daily`
- これらの API を利用しているフロントエンド画面
  - 営業ダッシュボード（顧客一覧・顧客比較・顧客離脱分析など）
  - 詳細ピボット画面（顧客 → 品目 → 明細のドリルダウン）

### 3.2 データベース

- 利用しているテーブル / ビュー / マテビュー（例）
  - `mart.mv_sales_tree_daily`
  - `mart.v_customer_sales_daily`
  - （必要に応じて sandbox / kpi スキーマのビューも列挙）

※ 本リファクタリングでは **スキーマやデータ構造を変更しない** 方針とする（必要であれば別プロジェクト・別マイグレーションとする）。

### 3.3 他バックエンドサービスとの連携

- 連携候補（例）
  - `ai_api`：営業関連の RAG や分析バッチで sales-tree API を利用している可能性。
  - `forecast_api`：将来、売上予測の前処理として sales-tree ビューを参照する可能性。
- 既存コードから「sales-tree 関連 API を呼んでいる箇所」を洗い出し、影響範囲として記録する。

---

## 4. リファクタリング方針・ルール

### 4.1 ブランチ運用（ルール 1）

- 必ず作業用ブランチを切ること。
- ブランチ名ルール（例）
  - `refactor/<対象>/YYYYMMDD_<概要>`
  - 例: `refactor/sales_tree/20251128_naming-cleanup`
- `stg` / `main` / `prod` ブランチに直接コミットしない。

### 4.2 小さくリファクタリングを行う（ルール 2）

- 1 PR / 1 目的を原則とする。
  - 例）
    - PR1: 命名リファクタリング（DTO・ドメイン・レスポンスの名前揺れ解消）
    - PR2: DI / UseCase / Repository の責務整理
    - PR3: テスト追加・カバレッジ向上
- コミットもできるだけ小さくまとめる。
  - 例）`refactor: unify sales tree dto naming`
  - 例）`test: add api snapshot test for /api/sales/tree`

### 4.3 機能同等性の担保（ルール 3）

- リファクタリングの前後で、以下が変わらないことを原則とする。
  - API URL / HTTP メソッド / ステータスコード
  - リクエストボディ・クエリパラメータの構造
  - レスポンス JSON の構造・キー名・型
  - 画面の表示内容・遷移・ボタン挙動
  - DB への読み書き内容
- 仕様改善が必要な場合
  - 「リファクタリング」とは別 PR / 別タスクとして扱い、混在させない。

### 4.4 フロントエンドとの連携確認（ルール 4）

- API I/F の互換性チェック
  - OpenAPI / TypeScript 型定義（ports / domain / model）の整合を確認。
  - レスポンス JSON の「キー名」や「ネスト構造」が変わっていないか diff で確認。
- FSD + MVVM + Repository パターンの順守
  - `features/<feature>/ui`：状態レスな View コンポーネントのみ。
  - `features/<feature>/model/useXxxViewModel`: 状態管理・イベント・ユースケース呼び出し。
  - `features/<feature>/ports`: Repository インターフェース定義。
  - `features/<feature>/infrastructure`: HTTP 呼び出し＋DTO整形。
- 主要画面の目視確認
  - 顧客一覧・顧客詳細・明細ドリルダウン等、主要なユーザーフローをチェックリスト化して検証する。

### 4.5 他バックエンドからの連携確認（ルール 5）

- `grep` / IDE 検索等で、sales-tree API を呼び出している箇所を列挙。
- 各呼び出し元で、以下を確認。
  - エンドポイント URL / HTTP メソッド / パラメータを変更していないか。
  - レスポンス構造の変更がある場合、呼び出し側でパースエラーが発生しないか。
- ステージング環境で、関連バッチ・定期ジョブを実行して動作確認する。

### 4.6 テスト戦略（追加ルール）

- 単体テスト
  - バックエンド
    - UseCase のテスト（ポートをモックしてビジネスロジックだけ検証）。
    - Domain エンティティ / 値オブジェクトの不変条件テスト。
  - フロントエンド
    - ViewModel（Hooks）のテスト：状態遷移・イベントハンドラの動作確認。
    - Repository 実装のテスト（API クライアントとの連携）。
- 統合テスト / API テスト
  - 主要 API について、リファクタ前後でレスポンス JSON を比較（スナップショットテスト）。
  - エラーケース（バリデーションエラー・タイムアウト等）の挙動も確認。
- 画面テスト
  - 手動でもよいので、主要シナリオのチェックリストを用意して実施。

### 4.7 DB・スキーマへの影響整理（必要時）

- 本リファクタリングでは、「DB スキーマ変更を行わない」ことを前提とする。
- もし View / Materialized View の SQL を変更する場合は、以下を明記。
  - SQL 定義ファイルの管理場所（例: `app/infra/db/views/mart/mv_sales_tree_daily.sql`）。
  - Alembic での取り扱い方針（View 更新専用のリビジョンを用意するか等）。
  - 過去バージョンの再現性をどこまで求めるか。

### 4.8 ロールバック方針

- Git レベル
  - 問題が発覚した場合、該当ブランチ / PR をリバートして元に戻す。
- DB レベル（必要時）
  - リリース前にバックアップを取得しておき、問題発生時には特定テーブル / スキーマのみ復元する。
- ロールバックの単位
  - 原則として「機能単位」「サービス単位」で戻せるようにする。

### 4.9 ドキュメント更新

- 更新対象
  - ER 図 / テーブル一覧（必要な場合）。
  - API 仕様書（OpenAPI / Postman コレクション）。
  - フロントエンドのアーキテクチャ図（FSD + MVVM 構成）。
- 実装とドキュメントの乖離を残さないよう、リファクタ完了時に必ず更新する。

### 4.10 コードレビュー方針

- レビュー観点
  - SOLID 原則に沿っているか（単一責任・依存関係逆転など）。
  - FSD + MVVM + Repository / Clean Architecture のレイヤー構成に沿っているか。
  - 循環参照・レイヤー違反がないか。
  - 命名・コメント・ログの粒度が適切か。
- PR テンプレ（例）
  - 変更内容
  - 目的
  - 影響範囲（API / 画面 / DB）
  - 実施したテスト内容（コマンド / 画面操作）

---

## 5. 実施ステップ例

1. **事前調査**
   - 対象コードの依存関係（呼び出し元・呼び出し先）を整理。
   - 既知の問題点・改善したいポイントを列挙。

2. **ブランチ作成**
   - 例）`git checkout -b refactor/sales_tree/20251128_naming-cleanup`

3. **小さな単位でリファクタリング**
   - ステップ例
     1. 命名整理（DTO・ドメイン・レスポンスの名前揺れ解消）。
     2. UseCase / Repository / Adapter の依存関係整理。
     3. テスト追加（単体 / API）。
     4. ログ・エラーハンドリングの統一。
   - 各ステップごとに PR を作り、レビュー＆マージしていく。

4. **テスト実行**
   - `pytest` / `npm test` / `npm run lint` など、既存のテストスイートを全実行。
   - 必要に応じて一時的なスナップショットテストを導入し、リファクタ前後のレスポンス比較を行う。

5. **ステージング環境で統合確認**
   - フロントエンド＋バックエンド＋他サービス（ai_api 等）を繋いだ状態でテスト。
   - ユーザーフロー単位での E2E 確認を行う。

6. **リリース & モニタリング**
   - 本番反映後しばらくは、ログ・メトリクス・エラーレートを重点的に監視。
   - 問題が見つかった場合は、ロールバック方針に従って迅速に対応。

---

## 6. リスクと対策

- **リスク1**: 影響範囲が広く、想定外の箇所が壊れる。
  - **対策**:
    - 事前に依存関係を洗い出し、影響範囲を設計書に明記する。
    - 主要ユースケースのテストケースをリスト化し、必ず実行する。

- **リスク2**: リファクタリングが長期化し、他開発とコンフリクトが多発する。
  - **対策**:
    - 小さなPRでこまめにマージする。
    - 大規模変更は段階的に行い、必要に応じて feature flag も検討する。

- **リスク3**: リファクタと仕様変更が混ざり、原因切り分けが困難になる。
  - **対策**:
    - 仕様変更は別PR・別タスクとして管理し、リファクタ PR では禁止とする。

---

## 7. チェックリスト（ToDo）

- [ ] 目的・対象範囲を明文化した。
- [ ] ブランチ戦略を決めた（命名ルール・運用ルール）。
- [ ] 影響 API / テーブル / 画面を列挙した。
- [ ] テスト方針（単体 / API / 画面）を決めた。
- [ ] DB / Alembic / View の扱い方針を決めた（今回は原則「変更なし」）。
- [ ] ロールバック方法を決めた（Git / DB）。
- [ ] ドキュメント更新対象を決めた。
- [ ] コードレビュー観点・PR テンプレを用意した。
- [ ] ステージング環境での統合テストを行った。
- [ ] 本番リリース後のモニタリング計画を決めた。

---

以上をベースに、実際の機能名やファイルパス、API 名を埋めていけば、
プロジェクト固有のリファクタリング設計書として利用できます。
